<!DOCTYPE html>
<html lang="zh">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=600">
    <meta http-equiv="X-UA-Compatible" content="ie=edge">
    <meta name="mobile-web-app-capable" content="yes">
    <meta name="apple-mobile-web-app-capable" content="yes">
    <title>danmaku overlay</title>
    <script src="webfx.min.js"></script>
    <style>
        body {
            margin: 10px 0;
            overflow: hidden;
        }
        .danmaku {
            position: absolute;
            font-family: sans-serif;
            font-weight: 700;
            line-height: 1;
            color: white;
            text-shadow: 0 0 .3em rgba(0,0,0,1), 0 0 .1em rgba(0,0,0,0.3);
            will-change: transform;
            white-space: pre;
        }
        .danmaku .pic {
            width: 1.2em;
            height: 1.2em;
            vertical-align: middle;
            border-radius: 50%;
            margin-right: .2em;
            box-shadow: 0 0 .3em rgba(0,0,0,0.24);
        }
        .danmaku .sender + .sender {
            margin-left: -.8em;
        }
        .danmaku .pic.at {
            font-size: 80%;
        }
        .danmaku .qface {
            width: 1.2em;
            height: 1.2em;
            vertical-align: sub;
        }
    </style>
</head>

<body>
    <div id="danmakus" style="font-size: 40px;">
    </div>
    <script>
        let fontSize = 40;
        const lineHeightFactor = 1.5;

        let duration = 10;

        let colors = ['white'];

        const { View, ContainerView } = webfx;

        /** @type {Danmaku[]} */
        let danmakus = new ContainerView(document.getElementById('danmakus'));
        class Danmaku extends View {
            constructor() {
                super();
                this.text = '';
                this.plaintext = '';
                this.x = 0;
                this.y = 0;
                this.width = 0;
                this.color = 'white';
                this.avatars = new ContainerView({tag: 'span.pics'});
            }
            createDom() {
                return {
                    tag: 'div.danmaku',
                    style: `color: ${this.color};`,
                    child: [
                        this.avatars,
                        this.textView = new View({ tag: 'span.text', child: this.text }),
                    ]
                }
            }
            updateDom() {
                super.updateDom();
                this.dom.style.transform = `translate(${this.x}px, ${this.y}px)`;
            }
            addSender(id) {
                this.avatars.addView(new Avatar(id, 'sender'));
                this.width = this.dom.scrollWidth;
            }
        }
        class Avatar extends View {
            constructor(id, type) {
                super();
                this.type = type;
                this.id = id;
            }
            createDom() {
                return { tag: 'img.pic.' + this.type, src: qqpic(this.id) };
            }
        }
        let lastMove = Date.now();
        function animate() {
            const now = Date.now();
            const step = (now - lastMove) * window.innerWidth / 1000 / duration;
            lastMove = now;
            const remove = [];
            for (const d of danmakus) {
                d.x -= step;
                d.updateDom();
                if (d.x + d.width < 0) remove.push(d);
            }
            for (const d of remove) {
                danmakus.removeView(d);
            }
            requestAnimationFrame(animate);
        }
        requestAnimationFrame(animate);
        function addDanmaku(d) {
            layoutDanmaku(d);
            danmakus.addView(d);
            d.width = d.dom.scrollWidth;
        }
        function layoutDanmaku(danmaku) {
            const winWidth = window.innerWidth;
            const lineHeight = fontSize * lineHeightFactor;
            let y = 0;
            outer: while(true) {
                for (const d of danmakus) {
                    if (d.y == y && d.x + d.dom.offsetWidth >= winWidth - fontSize) {
                        y += lineHeight;
                        continue outer;
                    }
                }
                break;
            }
            danmaku.x = winWidth;
            danmaku.y = y;
            danmaku.updateDom();
        }
        
        const chan = new BroadcastChannel("danmaku");
        chan.addEventListener('message', e => {
            const msg = e.data;
            if (msg.cmd == 'text') {
                const plaintext = msg.text.map(x => {
                    if (x.type == 'Plain') return x.text.replace(/\n/g, ' ');
                    if (x.type == 'Face') return `[face:${x.faceId}]`;
                    if (x.type == 'At') return `[at:${x.target}]`;
                }).join('');
                for (const it of danmakus) {
                    if (it.plaintext == plaintext && it.x >= window.innerWidth * 0.25) {
                        for (const pic of it.avatars) {
                            if (pic.id == msg.sender.id) return;
                        }
                        it.addSender(msg.sender.id);
                        return;
                    }
                }
                const d = new Danmaku();
                d.color = colors[msg.sender.id % colors.length];
                d.plaintext = plaintext;
                d.text = msg.text.map(x => {
                    if (x.type == 'Plain') return x.text.replace(/\n/g, ' ');
                    if (x.type == 'Face') return new View({ tag: 'img.qface', src: qqface(x.faceId) });
                    if (x.type == 'At') return ['@', new Avatar(x.target, 'at')];
                }); 
                d.addSender(msg.sender.id);
                addDanmaku(d);
            } else if (msg.cmd == 'setting') {
                fontSize = msg.fontSize;
                danmakus.dom.style.fontSize = msg.fontSize + 'px';
                duration = msg.duration;
                colors = msg.colors.split(',').filter(x => x);
                if (colors.length == 0) colors = ['white'];
            }
        });
        chan.postMessage({ cmd: 'sync' });

        // {
        //     const d = new Danmaku();
        //     d.text = 'HelloðŸ¦Š';
        //     d.pic = `https://q.qlogo.cn/g?b=qq&s=40&nk=10000`
        //     addDanmaku(d);
        // }

        function qqpic(id) {
            return `https://q.qlogo.cn/g?b=qq&s=40&nk=${id}`;
        }
        function qqface(id) {
            return `https://qq-face.vercel.app/gif/s${id}.gif`;
        }
    </script>
</body>

</html>